//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {mergeMap as _observableMergeMap, catchError as _observableCatch} from 'rxjs/operators';
import {Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf} from 'rxjs';
import {Injectable, Inject, Optional, InjectionToken} from '@angular/core';
import {HttpClient, HttpHeaders, HttpResponse, HttpResponseBase} from '@angular/common/http';
import {ClientBase} from './client-base';

export const IDENTITY_API_BASE_URL = new InjectionToken<string>('IDENTITY_API_BASE_URL');

@Injectable({
  providedIn: 'root'
})
export class IdentityApiClient extends ClientBase {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(IDENTITY_API_BASE_URL) baseUrl?: string) {
    super();
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Get all users
   * @param page (optional)
   * @param pageSize (optional)
   * @param includes (optional)
   * @param filters (optional)
   * @param sorts (optional)
   * @return Success
   */
  getUsers(page: number | undefined, pageSize: number | undefined, includes: string[] | undefined, filters: FilterModel[] | undefined, sorts: string[] | undefined): Observable<GetUsersResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/users?";
    if (page === null)
      throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "Page=" + encodeURIComponent("" + page) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (includes === null)
      throw new Error("The parameter 'includes' cannot be null.");
    else if (includes !== undefined)
      includes && includes.forEach(item => {
        url_ += "Includes=" + encodeURIComponent("" + item) + "&";
      });
    if (filters === null)
      throw new Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters && filters.forEach((item, index) => {
        for (let attr in item)
          if (item.hasOwnProperty(attr)) {
            url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
          }
      });
    if (sorts === null)
      throw new Error("The parameter 'sorts' cannot be null.");
    else if (sorts !== undefined)
      sorts && sorts.forEach(item => {
        url_ += "Sorts=" + encodeURIComponent("" + item) + "&";
      });
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUsers(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUsers(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetUsersResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetUsersResponse>;
    }));
  }

  protected processGetUsers(response: HttpResponseBase): Observable<GetUsersResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetUsersResponse;
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * UpdateUser
   * @param body (optional)
   * @return No Content
   */
  updateUser(body: UpdateUser | undefined): Observable<StatusCodeResult> {
    let url_ = this.baseUrl + "/api/v1/identity/users";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        "Accept": "text/plain"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StatusCodeResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StatusCodeResult>;
    }));
  }

  protected processUpdateUser(response: HttpResponseBase): Observable<StatusCodeResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeResult;
        return _observableOf(result204);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Register New User.
   * @return Created
   */
  registerUser(body: RegisterUserRequest): Observable<RegisterUserResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/users";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processRegisterUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRegisterUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RegisterUserResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RegisterUserResponse>;
    }));
  }

  protected processRegisterUser(response: HttpResponseBase): Observable<RegisterUserResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterUserResponse;
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  userRole(): Observable<StringOfF__AnonymousType1> {
    let url_ = this.baseUrl + "/api/v1/identity/user-role";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUserRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUserRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StringOfF__AnonymousType1>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StringOfF__AnonymousType1>;
    }));
  }

  protected processUserRole(response: HttpResponseBase): Observable<StringOfF__AnonymousType1> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringOfF__AnonymousType1;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  adminRole(): Observable<StringOfF__AnonymousType1> {
    let url_ = this.baseUrl + "/api/v1/identity/admin-role";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processAdminRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StringOfF__AnonymousType1>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StringOfF__AnonymousType1>;
    }));
  }

  protected processAdminRole(response: HttpResponseBase): Observable<StringOfF__AnonymousType1> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringOfF__AnonymousType1;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Login User
   * @return Success
   */
  login(body: LoginRequest): Observable<LoginResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processLogin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLogin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<LoginResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<LoginResponse>;
    }));
  }

  protected processLogin(response: HttpResponseBase): Observable<LoginResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResponse;
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Client error", status, _responseText, _headers, result404);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Server error", status, _responseText, _headers, result500);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Client error", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Login User With Google
   * @return Success
   */
  loginWithGoogle(body: LoginWithGoogleRequest): Observable<LoginWithGoogleResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/login-with-google";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processLoginWithGoogle(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoginWithGoogle(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<LoginWithGoogleResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<LoginWithGoogleResponse>;
    }));
  }

  protected processLoginWithGoogle(response: HttpResponseBase): Observable<LoginWithGoogleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginWithGoogleResponse;
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Client error", status, _responseText, _headers, result404);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Server error", status, _responseText, _headers, result500);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Client error", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Logout User
   * @param body (optional)
   * @return Success
   */
  logout(body: any | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/identity/logout";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processLogout(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLogout(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processLogout(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Sending Email Verification Code.
   * @return Success
   */
  sendEmailVerificationCode(body: SendEmailVerificationCodeRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/identity/send-email-verification-code";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processSendEmailVerificationCode(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSendEmailVerificationCode(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processSendEmailVerificationCode(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result409: any = null;
        result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Verifying Email
   * @return Success
   */
  verifyEmail(body: VerifyEmailRequest): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/identity/verify-email";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processVerifyEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processVerifyEmail(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processVerifyEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result409: any = null;
        result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Revoking Refresh Token
   * @return No Content
   */
  revokeRefreshToken(body: RevokeRefreshTokenRequest): Observable<StatusCodeProblemDetails> {
    let url_ = this.baseUrl + "/api/v1/identity/revoke-refresh-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processRevokeRefreshToken(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRevokeRefreshToken(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StatusCodeProblemDetails>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StatusCodeProblemDetails>;
    }));
  }

  protected processRevokeRefreshToken(response: HttpResponseBase): Observable<StatusCodeProblemDetails> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return _observableOf(result204);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Revoking Token
   * @param body (optional)
   */
  revokeAccessToken(body: RevokeAccessTokenRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/identity/revoke-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processRevokeAccessToken(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRevokeAccessToken(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processRevokeAccessToken(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Getting User Claims
   * @param body (optional)
   * @return Success
   */
  claims(body: any | undefined): Observable<GetClaimsResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/claims";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processClaims(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClaims(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GetClaimsResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GetClaimsResponse>;
    }));
  }

  protected processClaims(response: HttpResponseBase): Observable<GetClaimsResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClaimsResponse;
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Client error", status, _responseText, _headers, result401);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * RefreshToken
   * @param body (optional)
   * @return Success
   */
  refreshToken(body: RefreshTokenRequest | undefined): Observable<RefreshTokenResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/refresh-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        "Accept": "text/plain"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processRefreshToken(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRefreshToken(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RefreshTokenResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RefreshTokenResponse>;
    }));
  }

  protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RefreshTokenResponse;
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Updating User State.
   * @return No Content
   */
  updateUserState(userId: string, body: UpdateUserStateRequest): Observable<RegisterUserResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/users/{userId}/state";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateUserState(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateUserState(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RegisterUserResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RegisterUserResponse>;
    }));
  }

  protected processUpdateUserState(response: HttpResponseBase): Observable<RegisterUserResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterUserResponse;
        return _observableOf(result204);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Getting User by InternalCommandId
   * @return Success
   */
  getUserById(userId: string): Observable<RegisterUserResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/users/{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RegisterUserResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RegisterUserResponse>;
    }));
  }

  protected processGetUserById(response: HttpResponseBase): Observable<RegisterUserResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterUserResponse;
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * Getting User by email.
   * @param body (optional)
   * @return Success
   */
  getUserByEmail(email: string, body: any | undefined): Observable<RegisterUserResponse> {
    let url_ = this.baseUrl + "/api/v1/identity/users/by-email/{email}";
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace("{email}", encodeURIComponent("" + email));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserByEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserByEmail(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RegisterUserResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RegisterUserResponse>;
    }));
  }

  protected processGetUserByEmail(response: HttpResponseBase): Observable<RegisterUserResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterUserResponse;
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Client error", status, _responseText, _headers, result404);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StatusCodeProblemDetails;
        return throwException("Client error", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface ClaimDto {
  type?: string | undefined;
  value?: string | undefined;
}

export interface FilterModel {
  fieldName?: string | undefined;
  comparision?: string | undefined;
  fieldValue?: string | undefined;
}

export interface GetClaimsResponse {
  claims?: ClaimDto[] | undefined;
}

export interface GetUsersResponse {
  identityUsers?: IdentityUserDtoListResultModel;
}

export interface IdentityUserDto {
  id?: string;
  userName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  lastLoggedInAt?: Date | undefined;
  refreshTokens?: string[] | undefined;
  roles?: string[] | undefined;
  userState?: UserState;
  createdAt?: Date;
}

export interface IdentityUserDtoListResultModel {
  items?: IdentityUserDto[] | undefined;
  totalItems?: number;
  page?: number;
  pageSize?: number;
}

export interface LoginRequest {
  userNameOrEmail?: string | undefined;
  password?: string | undefined;
  remember?: boolean;
}

export interface LoginResponse {
  readonly userId?: string;
  accessToken?: string | undefined;
  readonly firstName?: string | undefined;
  readonly lastName?: string | undefined;
  readonly username?: string | undefined;
  refreshToken?: string | undefined;
}

export interface LoginWithGoogleRequest {
  credential?: string | undefined;
}

export interface LoginWithGoogleResponse {
  readonly userId?: string;
  accessToken?: string | undefined;
  readonly firstName?: string | undefined;
  readonly lastName?: string | undefined;
  readonly username?: string | undefined;
  refreshToken?: string | undefined;
}

export interface RefreshTokenRequest {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
}

export interface RefreshTokenResponse {
  accessToken?: string | undefined;
  readonly userId?: string;
  readonly firstName?: string | undefined;
  readonly lastName?: string | undefined;
  readonly username?: string | undefined;
  refreshToken?: string | undefined;
}

export interface RegisterUserRequest {
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  roles?: string[] | undefined;
}

export interface RegisterUserResponse {
  userIdentity?: IdentityUserDto;
}

export interface RevokeAccessTokenRequest {
  accessToken?: string | undefined;
}

export interface RevokeRefreshTokenRequest {
  refreshToken?: string | undefined;
}

export interface SendEmailVerificationCodeRequest {
  email?: string | undefined;
}

export interface StatusCodeProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export interface StatusCodeResult {
  statusCode?: number;
}

export interface StringOfF__AnonymousType1 {
  role?: string | undefined;
}

export interface UpdateUser {
  userId?: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
}

export interface UpdateUserStateRequest {
  userState?: UserState;
}

/** 1 = Active 2 = Locked */
export enum UserState {
  Active = 1,
  Locked = 2,
}

export interface VerifyEmailRequest {
  email?: string | undefined;
  code?: string | undefined;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: {
  [key: string]: any;
}, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
